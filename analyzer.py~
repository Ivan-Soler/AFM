import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import axes3d, Axes3D
from scipy import interpolate
from scipy.interpolate import RegularGridInterpolator
from scipy.interpolate import interpn
import Projecting
import Plotting
import Read
import Maxima_find
import Fitting
import Fit_1d
import subprocess
import math
import re
from subprocess import call

plt.rcParams.update({'font.size': 12})


def fit_impr(folder,file,zm_top,normalization):
    
    if zm_top:
        density,sizes=Read.ascii_mode(file)
        title="susy"
    else:
        density,sizes=Read.topology(file)
        title="top"
    res=Maxima_find.simple(density,sizes)
    density=density*4*np.pi*np.pi*len(res[0])*normalization
    Plotting.plot_all_peaks(folder,density, sizes, title)

    param_all=[[]]
    param_all.pop(0)
    param_temp=[[]]
    param_temp.pop(0)

    err_all=[[]]
    err_all.pop(0)
    err_temp=[[]]
    err_temp.pop(0)
    for i in range(0,len(res[0])):
        param_temp=[[]]
        param_temp.pop(0)
        for d in range(0,4):
            Xmax=[res[0,i],res[1,i],res[2,i],res[3,i]]
            popt_temp,pcov_temp=Fitting.fitting_instanton_impr(density, d, sizes, Xmax, "0") #h,x,rho
            param_temp.append(popt_temp)
            err_temp.append(np.sqrt(np.diag(pcov_temp)))
        param_all.append(param_temp)
        err_all.append(err_temp)

    param=np.array(param_all)
    err=np.array(err_all)

    #param_mean=err_mean=np.zeros((len(res[0]),6))
    #for j in range(0,len(res[0])):
    #    for d in(0,3):
    #        param_mean[j][d]=param[j][d][1] #adding position     
    #        err_mean[j][d]=err[j][d][1]
    #    for k in(4,5):
    #        param_mean[j][k]=np.mean(param[j][:][0])
    #        err_mean[j][k]=np.mean(err[j][:][0])
            
    return density, param, err 

def fit_simple(folder,file,zm_top,normalization):
    if zm_top:
        density,sizes=Read.ascii_mode(file)
        res=Maxima_find.simple(density,sizes)
        density=density*4*np.pi*np.pi*len(res[0])
        title="susy"
    else:
        density,sizes=Read.topology(file)
        #density=density*normalization/density.sum()
        res=Maxima_find.simple(density,sizes)
        title="top"
    
    Plotting.plot_all_peaks(folder,density, sizes, title)

    param_all=[[]]
    param_all.pop(0)
    param_temp=[[]]
    param_temp.pop(0)

    for i in range(0,len(res[0])):
        param_temp=[[]]
        param_temp.pop(0)
        for d in range(0,4):
            Xmax=[res[0,i],res[1,i],res[2,i],res[3,i]]
            popt_temp=Fitting.fitting_instanton(density, d, sizes, Xmax, "0")
            param_temp.append(popt_temp)
        param_all.append(param_temp)

    param=np.array(param_all)

    #param_mean=err_mean=np.zeros((len(res[0]),6))
    #for j in range(0,len(res[0])):
    #    for d in(0,3):
    #        param_mean[j][d]=param[j][d][1] #adding position     
    #        err_mean[j][d]=err[j][d][1]
    #    for k in(4,5):
    #        param_mean[j][k]=np.mean(param[j][:][0])
    #        err_mean[j][k]=np.mean(err[j][:][0])
    return density, param

def Xi(densityA,densityB):
    Xi=0
    meanA=np.mean(densityA)
    meanB=np.mean(densityB)
    sizes=[len(densityA[0]),len(densityA[1]),len(densityA[2]),len(densityA[3])]
    volume=sizes[0]*sizes[1]*sizes[2]*sizes[3]
    meanA=np.mean(densityA)
    meanB=np.mean(densityB)
    for x in range(sizes[0]):
        for y in range(sizes[1]):
            for z in range(sizes[2]):
                for t in range(sizes[3]):
                    Xi+=((densityA[x,y,z,t]-meanA)*(densityB[x,y,z,t]-meanB))/volume
    return Xi

def Geom_mean(densityA,densityB):
    GM=(Xi(densityA,densityB)*Xi(densityA,densityB))/(Xi(densityA,densityA)*Xi(densityB,densityB))
    
    return GM

def Xi_1d(densityA,densityB):
    Xi=0
    meanA=np.mean(densityA)
    meanB=np.mean(densityB)
    sizes=[len(densityA)]
    volume=sizes[0]
    meanA=np.mean(densityA)
    meanB=np.mean(densityB)
    for t in range(sizes[0]):
        Xi+=((densityA[t]-meanA)*(densityB[t]-meanB))/volume
    return Xi

def Geom_mean_1d(densityA,densityB):
    GM=(Xi_1d(densityA,densityB)*Xi_1d(densityA,densityB))/(Xi_1d(densityA,densityA)*Xi_1d(densityB,densityB))
    
    return GM

def IPR(density):
    IPR=0
    for i in range(0,len(density)):
        IPR+=density[i]*density[i]
    return(len(density)*IPR)


def RPO(densityA,densityB,thresholdA):
    volA=0
    volB=0
    vol_union=0
    vol_inter=0
    for element in densityA:
        if element > thresholdA:
            volA+=1
    if volA==0:
        return(0)
    stop=0
    stop_max=10000
    thresholdB=thresholdA
    while (volA!=volB) and (stop<stop_max): 
        volB=0
        stop+=1
        for element in densityB:
            if element > thresholdB:
                volB+=1
        thresholdB-=0.01
    thresholdB+=0.01    
    if (stop<stop_max):
        for t in range(0,len(densityA)):
            if (densityA[t]>thresholdA) and (densityB[t]>thresholdB):
                vol_inter+=1
            if (densityA[t]>thresholdA) or (densityB[t]>thresholdB):
                vol_union+=1  
        return (vol_inter/vol_union)
    else:
        trehsoldB=thresholdA
        stop=0
        while (volA!=volB) and (stop<1000):
            
            volB=0
            stop+=1
            for element in densityB:
                if element > thresholdB:
                    volB+=1
            thresholdB+=0.01 
        thresholdB-=0.01    
        if (stop<stop_max):
            for t in range(0,len(densityA),1):
                if (densityA[t]>thresholdA) and (densityB[t]>thresholdB):
                    vol_inter+=1
                if (densityA[t]>thresholdA) or (densityB[t]>thresholdB):
                    vol_union+=1   
            return (vol_inter/vol_union)
        
        else:
            print("RPO volume did not converged")
            return (0)
        
def Index(conf_tot,threshold):

    #Overlap
    count_s0_ov=np.zeros(conf_tot+1)
    index_ov=np.zeros(conf_tot+1)
    with open("./sector_0/Measure.seq") as file:
        for line in file:
            match=re.search(":OverlapFilterModeC:",line)
            if match:
                string=line.split(":")
                if (abs(float(string[8]))<threshold):
                    count_s0_ov[int(int(string[1]))]+=1.
                    index_ov[int(int(string[1]))]-=1./(2*2)

    count_s1_ov=np.zeros(conf_tot+11)
    with open("./sector_1/Measure.seq") as file:
        for line in file:
            match=re.search(":OverlapFilterModeC:",line)
            if match:
                string=line.split(":")
                if (abs(float(string[8]))<threshold):
                    count_s1_ov[int(int(string[1]))]+=1.
                    index_ov[int(int(string[1]))]+=1./(2*2)

    #Susy
    index_r=np.zeros(conf_tot+1)
    count_s0_r=np.zeros(conf_tot+1)
    with open("./sector_0/Measure.seq") as file:
        for line in file:
            match=re.search(":OverlapFilterModeR:",line)
            if match:
                string=line.split(":")
                if (abs(float(string[8]))<threshold):
                    count_s0_r[int(int(string[1]))]+=1.
                    index_r[int(int(string[1]))]-=1./(2)

    count_s1_r=np.zeros(conf_tot+1)
    with open("./sector_1/Measure.seq") as file:
        for line in file:
            match=re.search(":OverlapFilterModeR:",line)
            if match:
                string=line.split(":")
                if (abs(float(string[8]))<threshold):
                    count_s1_r[int(int(string[1]))]+=1.
                    index_r[int(int(string[1]))]+=1./(2)
    #GF
    top=np.zeros(conf_tot+11)
    with open("../gf/Measure.seq") as file:
        for line in file:
            match=re.search(":TopologicalCharge:t:4",line)
            if match:
                string=line.split(":")
                top[int(int(string[1]))]=round((float(string[7])))
                
    mean_index_ov=np.sum(np.abs(index_ov-top))
    mean_index_re=np.sum(np.abs(index_r-top))
    
    return(mean_index_ov,mean_index_re)
    
